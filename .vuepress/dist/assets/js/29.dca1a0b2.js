(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{161:function(t,r,s){"use strict";s.r(r);var e=s(18),n=Object(e.a)({},function(){var t=this,r=t.$createElement,s=t._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"操作系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#操作系统","aria-hidden":"true"}},[t._v("#")]),t._v(" 操作系统")]),t._v(" "),s("h2",{attrs:{id:"进程互斥"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程互斥","aria-hidden":"true"}},[t._v("#")]),t._v(" 进程互斥")]),t._v(" "),s("p",[t._v("操作系统中，"),s("strong",[t._v("进程")]),t._v("是资源占有的最小单位，"),s("strong",[t._v("线程")]),t._v("可以访问其所在进程内的所有资源，但线程本身不占有资源或仅占有一点点资源。\n对于某些资源来说，同一时间只能被一个进程占用，这种资源就是"),s("strong",[t._v("临界资源")]),t._v("。如打印机、硬盘内一些变量和数据等。\n对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。\n而进程内访问临界资源的代码被成为"),s("strong",[t._v("临界区")]),t._v("。")])])},[],!1,null,null,null);n.options.__file="operating-system.md";r.default=n.exports}}]);